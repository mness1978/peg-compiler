#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "parser.h"
#include "ast.h"
#include "compiler.h"
// #include "vm.h" // VM includes are no longer needed in the compiler



// Action to print the captured key - no longer needed in pegcc
/*
int print_key_action(void *vm_context) {
    VMContext *ctx = (VMContext *)vm_context;
    printf("Found key: %s\n", ctx->capture_buffer);
    return 1;
}
*/

int main(int argc, char **argv) {
    int verbose = 0;
    int arg_offset = 0;

    if (argc > 1 && strcmp(argv[1], "-v") == 0) {
        verbose = 1;
        arg_offset = 1;
    }

    if (argc < (3 + arg_offset)) {
        fprintf(stderr, "Usage: %s [-v] <peg_grammar_file> <output_bytecode_file.pbc>\n", argv[0]);
        return 1;
    }

    const char *grammar_filename = argv[1 + arg_offset];
    const char *output_bytecode_filename = argv[2 + arg_offset];
    FILE *f = fopen(grammar_filename, "rb");
    if (!f) {
        perror("Failed to open grammar file");
        return 1;
    }

    fseek(f, 0, SEEK_END);
    long fsize = ftell(f);
    fseek(f, 0, SEEK_SET);

    char *grammar_buffer = (char *)malloc(fsize + 1);
    if (!grammar_buffer) {
        perror("Failed to allocate grammar buffer");
        fclose(f);
        return 1;
    }
    size_t bytes_read = fread(grammar_buffer, 1, fsize, f);
    if (bytes_read != fsize) { /* handle error or partial read */ }
    fclose(f);
    grammar_buffer[fsize] = '\0';

    // --- Parse the PEG Grammar ---
    ParserContext parser_ctx;
    parser_init(&parser_ctx, grammar_buffer, fsize);
    parser_ctx.verbose = verbose; // Set verbose flag in parser context

    printf("Parsing grammar from %s...\n", grammar_filename);
    ASTNode *grammar_ast = parse_grammar(&parser_ctx);

    if (!grammar_ast) {
        fprintf(stderr, "Parsing grammar failed at line %d, column %d: %s\n",
                parser_ctx.line, parser_ctx.column, parser_ctx.error_message ? parser_ctx.error_message : "Unknown error");
        free(grammar_buffer);
        parser_cleanup(&parser_ctx);
        return 1;
    }
    printf("Parsing grammar successful!\n");
    print_ast_node(grammar_ast, 0); // Uncomment to print the AST

    // --- Compile the AST into Bytecode ---
    CompilerContext compiler_ctx;
    compiler_init(&compiler_ctx);
    compiler_ctx.verbose = verbose;

    // Populate action table - this is a placeholder for the compiler.
    // The actual action functions will be linked in the VM.
    // For now, we just ensure the action_table_ptr is set correctly if actions are used.
    // The compiler only needs to know the *number* of actions, not their implementation.
    compiler_ctx.action_table_ptr = 0; // Reset to 0, as compiler doesn't need to populate it with actual functions

    printf("Compiling grammar to bytecode...\n");
    if (!compiler_compile(&compiler_ctx, grammar_ast)) {
        fprintf(stderr, "Compilation failed at line %d, column %d: %s\n",
                compiler_ctx.error_line, compiler_ctx.error_column, compiler_ctx.error_message ? compiler_ctx.error_message : "Unknown error");
        ast_free(grammar_ast);
        free(grammar_buffer);
        compiler_cleanup(&compiler_ctx);
        parser_cleanup(&parser_ctx);
        return 1;
    }
    printf("Compilation successful! Generated %d instructions.\n", compiler_ctx.bytecode_ptr);

    // --- Print Generated Bytecode --- (Moved to a separate debug utility or removed)
    // This section is removed from the main compiler flow.
    /*
    printf("\nGenerated Bytecode:\n");
    for (int i = 0; i < compiler_ctx.bytecode_ptr; ++i) {
        Instruction instr = compiler_ctx.bytecode[i];
        printf("%04d: OpCode %d (Operand: %d)", i, instr.opcode, instr.operand);
        switch (instr.opcode) {
            case OP_MATCH_LITERAL: printf(" MATCH_LITERAL \"%s\"", compiler_ctx.string_table[instr.operand]); break;
            case OP_MATCH_CHAR_CLASS: printf(" MATCH_CHAR_CLASS \"%s\"", compiler_ctx.char_class_table[instr.operand]); break;
            case OP_MATCH_ANY: printf(" MATCH_ANY"); break;
            case OP_CALL:
                {
                    const char *rule_name = "UNKNOWN";
                    for (int r_idx = 0; r_idx < compiler_ctx.rules_ptr; ++r_idx) {
                        if (compiler_ctx.rules[r_idx].address == instr.operand) {
                            rule_name = compiler_ctx.rules[r_idx].name;
                            break;
                        }
                    }
                    printf(" CALL (Target Addr: %d, Rule: %s)", instr.operand, rule_name);
                }
                break;
            case OP_RETURN: printf(" RETURN"); break;
            case OP_CHOICE: printf(" CHOICE (Fail Addr: %d)", instr.operand); break;
            case OP_COMMIT: printf(" COMMIT (Next Addr: %d)", instr.operand); break;
            case OP_PARTIAL_COMMIT: printf(" PARTIAL_COMMIT (Next Addr: %d)", instr.operand); break;
            case OP_JUMP: printf(" JUMP (Target Addr: %d)", instr.operand); break;
            case OP_AND_PREDICATE: printf(" AND_PREDICATE"); break;
            case OP_NOT_PREDICATE: printf(" NOT_PREDICATE"); break;
            case OP_OPTIONAL: printf(" OPTIONAL"); break;
            case OP_ZERO_OR_MORE: printf(" ZERO_OR_MORE"); break;
            case OP_ONE_OR_MORE: printf(" ONE_OR_MORE"); break;
            case OP_BEGIN_CAPTURE: printf(" BEGIN_CAPTURE"); break;
            case OP_END_CAPTURE: printf(" END_CAPTURE"); break;
            case OP_ACTION: printf(" ACTION (ID: %d)", instr.operand); break;
            case OP_HALT: printf(" HALT"); break;
            case OP_FAIL: printf(" FAIL"); break;
            default: printf(" UNKNOWN_OPCODE"); break;
        }
        printf("\n");
    }
    printf("\n");
    */

    // --- Write Compiled Bytecode to File ---
    printf("Writing bytecode to %s...\n", output_bytecode_filename);
    if (!compiler_write_bytecode_file(&compiler_ctx, output_bytecode_filename)) {
        fprintf(stderr, "Failed to write bytecode file.\n");
        ast_free(grammar_ast);
        free(grammar_buffer);
        compiler_cleanup(&compiler_ctx);
        parser_cleanup(&parser_ctx);
        return 1;
    }
    printf("Bytecode written successfully.\n");

    // --- VM Execution part removed ---
    /*
    const char *input_filename = argv[2];
    FILE *input_f = fopen(input_filename, "rb");
    if (!input_f) {
        perror("Failed to open input file");
        return 1;
    }

    fseek(input_f, 0, SEEK_END);
    long input_fsize = ftell(input_f);
    fseek(input_f, 0, SEEK_SET);

    char *input_buffer = (char *)malloc(input_fsize + 1);
    if (!input_buffer) {
        perror("Failed to allocate input buffer");
        fclose(input_f);
        return 1;
    }
    size_t input_bytes_read = fread(input_buffer, 1, input_fsize, input_f);
    if (input_bytes_read != input_fsize) { // handle error or partial read }
    fclose(input_f);
    input_buffer[input_fsize] = '\0';


    VMContext vm_ctx;
    // Allocate rule_entry_points dynamically for vm_init
    int *vm_rule_entry_points = (int *)malloc(sizeof(int) * compiler_ctx.rules_ptr);
    if (!vm_rule_entry_points) {
        perror("Failed to allocate VM rule entry points");
        ast_free(grammar_ast);
        free(grammar_buffer);
        compiler_cleanup(&compiler_ctx);
        parser_cleanup(&parser_ctx);
        return 1;
    }

    // Copy rule entry points
    for (int i = 0; i < compiler_ctx.rules_ptr; ++i) {
        vm_rule_entry_points[i] = compiler_ctx.rules[i].address;
    }

    vm_init(&vm_ctx,
            input_buffer, input_fsize,
            compiler_ctx.bytecode, compiler_ctx.bytecode_ptr,
            (const char **)compiler_ctx.string_table, compiler_ctx.string_table_ptr,
            (const char **)compiler_ctx.char_class_table, compiler_ctx.char_class_table_ptr,
            compiler_ctx.action_table, compiler_ctx.action_table_ptr,
            vm_rule_entry_points, compiler_ctx.rules_ptr,
            NULL); // No user data for now

    printf("Running VM with input from: \"%s\"...\n", input_filename);
    // Assuming the first rule in the grammar is the starting rule (index 0)
    int vm_result = vm_run(&vm_ctx, 0);

    if (vm_result >= 0) {
        printf("VM execution successful! Input matched.\n");
        if (vm_ctx.capture_end_pos > vm_ctx.capture_start_pos) {
            printf("Captured text (yytext): \"%s\"\n", vm_ctx.capture_buffer);
        }
    } else {
        fprintf(stderr, "VM execution failed: %s at position %zu\n",
                vm_ctx.error_message ? vm_ctx.error_message : "Unknown error",
                vm_ctx.error_pos);
    }
    free(vm_rule_entry_points); // Free allocated rule entry points
    vm_cleanup(&vm_ctx);
    free(input_buffer);
    */

    // --- Cleanup ---
    printf("DEBUG: ast_free\n");
    ast_free(grammar_ast);
    printf("DEBUG: free grammar_buffer\n");
    free(grammar_buffer);
    printf("DEBUG: compiler_cleanup\n");
    compiler_cleanup(&compiler_ctx);
    printf("DEBUG: parser_cleanup\n");
    parser_cleanup(&parser_ctx);
    printf("DEBUG: return 0\n");

    return 0;
}
